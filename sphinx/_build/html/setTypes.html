<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Set Types &mdash; Tupul 0.0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Type" href="type.html" />
    <link rel="prev" title="Functions" href="functions.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Tupul
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="conditionals.html">Conditionals</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">Functions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Set Types</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">In-Progress:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="type.html">Type</a></li>
<li class="toctree-l1"><a class="reference internal" href="interface.html">Interface</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Tupul</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Set Types</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/setTypes.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="set-types">
<h1>Set Types<a class="headerlink" href="#set-types" title="Permalink to this headline"></a></h1>
<p>Tupul’s types are derived from many of the ideas and notations of Zermelo–Fraenkel set theory</p>
<p>These allow for defining functions that guarantee return values because of parameter types.</p>
<p>This is confusing, I will explain.</p>
<p>In something like Java one might see a function like this</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="n">Item</span> <span class="nf">getItem</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//... code that gets the item.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Or errors in using arrays</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="o">[]</span> <span class="n">myCharArray</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">myCharArray</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span> <span class="c1">//Causes an error.</span>
</pre></div>
</div>
<p>There is some argument to be made for simply passing these errors on, and ignoring the fact that types don’t really show
what kind of types should be used for functions. However, Tupul allows you to define (and any type defined equivelently as another type
is interchangable) custom types using Set theory.</p>
<p>This means that along with having types certiantly return a value, you can also union the type “false” which is part of boolean, with
any other type.</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">ItemOptional</span> <span class="p">:</span> <span class="n">Item</span> <span class="n">union</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">//Also valid is Item | false</span>

<span class="n">ItemOptional</span> <span class="nf">getItem</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span><span class="c1">//...code}</span>
</pre></div>
</div>
<p>However, because having an optional thing is so common, all types have a .optional extension that is this:</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="n">Object</span><span class="p">.</span><span class="na">optional</span> <span class="p">:</span> <span class="n">Object</span> <span class="n">union</span> <span class="kc">null</span>
</pre></div>
</div>
<p>null only exists in this .optional type, and is falsy. It is not a classic null, you can only use it in unions and return types.
You cannot assign anything to null unless it is a subtype of null.
So</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="n">Class</span> <span class="n">myObject</span><span class="p">;</span> <span class="c1">//Invalid</span>
<span class="n">Class</span> <span class="n">myOtherObject</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">//Also Invalid</span>
</pre></div>
</div>
<p>null is falsy, and everything else is truthy.</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="n">Item</span><span class="p">.</span><span class="na">optional</span> <span class="nf">getItem</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span><span class="c1">//...code}</span>
</pre></div>
</div>
<p>Any conversion between a type and a type that is a strict subset of it happens without casting.</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">PositiveInt</span> <span class="p">:</span> <span class="n">Set</span><span class="p">.</span><span class="na">naturalNumbers</span><span class="p">.</span><span class="na">greater</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="n">PostiveInt</span> <span class="n">myPositiveInt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">mySecondInt</span> <span class="o">=</span> <span class="n">myPositiveInt</span><span class="p">;</span> <span class="c1">//Doesn&#39;t need casting because it is a strict subset.</span>
</pre></div>
</div>
<p>In this case though, you would need some extra steps called validation, which we will go over later.</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">PosIntString</span> <span class="p">:</span> <span class="n">Set</span><span class="p">.</span><span class="na">naturalNumbers</span><span class="p">.</span><span class="na">greater</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">union</span> <span class="n">string</span><span class="p">;</span>

<span class="n">PosIntString</span> <span class="n">customNum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//Valid</span>

<span class="kt">int</span> <span class="n">mySecondInt</span> <span class="o">=</span> <span class="n">customNum</span><span class="p">;</span> <span class="c1">//Invalid.</span>
</pre></div>
</div>
<p>If you want to check if a type is a subset of another you use the subset keyword.</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">PosInt</span> <span class="p">:</span> <span class="n">Set</span><span class="p">.</span><span class="na">naturalNumbers</span><span class="p">.</span><span class="na">greater</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">typedef</span> <span class="n">PosIntString</span> <span class="p">:</span> <span class="n">Set</span><span class="p">.</span><span class="na">naturalNumbers</span><span class="p">.</span><span class="na">greater</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">union</span> <span class="n">string</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm">also valid would be</span>
<span class="cm">typedef PosInt : Set.naturalNumbers.greater(-1);</span>
<span class="cm">typedef PosIntString : PosInt | string;</span>
<span class="cm">*/</span>

<span class="n">PosIntString</span> <span class="n">customNum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//Valid</span>

<span class="kt">int</span> <span class="n">mySecondInt</span> <span class="o">=</span> <span class="n">customNum</span><span class="p">;</span> <span class="c1">//Invalid.</span>

<span class="kt">int</span> <span class="n">myInt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span><span class="n">myInt</span><span class="p">.</span><span class="na">class</span> <span class="n">subset</span> <span class="n">PosIntString</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//This is true</span>
<span class="p">}</span>

<span class="k">if</span><span class="p">(</span><span class="n">myInt</span><span class="p">.</span><span class="na">class</span> <span class="n">strictsubset</span> <span class="n">PosIntString</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//This is false becuase &#39;string&#39; isn&#39;t a part of the &#39;int&#39; type</span>
<span class="p">}</span>

<span class="k">if</span><span class="p">(</span><span class="n">myInt</span> <span class="k">instanceof</span> <span class="n">PosIntString</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//This is false, because -1 isn&#39;t in the PosIntString set.</span>
<span class="p">}</span>
<span class="k">if</span><span class="p">(</span><span class="n">myInt</span> <span class="k">instanceof</span> <span class="n">PosInt</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//This is false, because -1 isn&#39;t in the PosInt set.</span>
<span class="p">}</span>
<span class="n">myInt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">myInt</span> <span class="k">instanceof</span> <span class="n">PosIntString</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//This is true</span>
<span class="p">}</span>
<span class="k">if</span><span class="p">(</span><span class="n">myInt</span> <span class="k">instanceof</span> <span class="n">PosInt</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//This is true</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, this leads into a second piece about Set syntax in tupul.
You can define new, or redifine existing types if they are a subsets within conditionals.
Reusing our example from earlier:</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">PosInt</span> <span class="p">:</span> <span class="n">Set</span><span class="p">.</span><span class="na">naturalNumbers</span><span class="p">.</span><span class="na">greater</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">myInt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span><span class="n">myInt</span> <span class="k">instanceof</span> <span class="n">PosInt</span> <span class="o">-&gt;</span> <span class="n">PosInt</span> <span class="n">newInt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="n">newInt</span><span class="p">);</span> <span class="c1">//This creates a newInt that is the value of myInt.</span>
<span class="p">}</span>

<span class="c1">//But you can also just redefine a variable within the scope of the conditional.</span>

<span class="k">if</span><span class="p">(</span><span class="n">myInt</span> <span class="k">instanceof</span> <span class="n">PosInt</span> <span class="o">-&gt;</span> <span class="n">myInt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="n">myInt</span><span class="p">);</span> <span class="c1">//myInt within this scope is no longer a &#39;int&#39; type it is a &#39;PosInt&#39; type.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This can be changed together by isolating with parenthesis.</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">int1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">int2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">int1</span> <span class="k">instanceof</span> <span class="n">PosInt</span> <span class="o">-&gt;</span> <span class="n">int1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">int2</span> <span class="k">instanceof</span> <span class="n">PosInt</span> <span class="o">-&gt;</span> <span class="n">int2</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;int1: &quot;</span> <span class="o">+</span> <span class="n">int1</span><span class="p">);</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;int2: &quot;</span> <span class="o">+</span> <span class="n">int2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, back to the optional type.</p>
<p>You can use conditionals on only booleans, and types that subset boolean values.
If you run a conditional, and the type subsets the boolean values true, false, or just one of them, then
the conditional evaluates the statement as false if it is indeed a false boolean, and true otherwise.
Thus, unless you are explicitly checking instanceof, subsetting ‘true’ is not necessary.</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="n">Item</span><span class="p">.</span><span class="na">optional</span> <span class="nf">getItem</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span><span class="c1">//...code}</span>

<span class="k">if</span><span class="p">(</span><span class="n">getItem</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span> <span class="c1">//This evaluates to false if it is an instance of &#39;false&#39; and true otherwise.</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;has an item&quot;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;doesn&#39;t have an item&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As show in the Functions page, you can get a value from this.</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="n">Item</span><span class="p">.</span><span class="na">optional</span> <span class="nf">getItem</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span><span class="c1">//...code}</span>

<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">getItem</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span> <span class="n">Item</span><span class="p">.</span><span class="na">optional</span> <span class="n">myItem</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;doesn&#39;t have item&quot;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">myItem</span> <span class="k">instanceof</span> <span class="n">Item</span> <span class="o">-&gt;</span> <span class="n">myItem</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;my item is: &quot;</span> <span class="o">+</span> <span class="n">myItem</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This forces you to invert your if statements if you are checking optionality, because getItem returns a Item.optional and not a Item.
And Item is not a strict subset of Item.optional, just a subset.</p>
<p>Taking all of this together, we can rewrite our code from above with more explicit error checking.</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="n">typedef</span> <span class="n">PostiveInt</span> <span class="p">:</span> <span class="n">Set</span><span class="p">.</span><span class="na">naturalNumbers</span><span class="p">.</span><span class="na">greaterThan</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">myVal</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">myVal</span> <span class="n">subsetof</span> <span class="n">PositiveInt</span> <span class="o">-&gt;</span> <span class="n">myVal</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">getItem</span><span class="p">(</span><span class="n">myVal</span><span class="p">):</span> <span class="n">ItemOptional</span> <span class="n">returnItem</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">print</span><span class="p">(</span><span class="s">&quot;Item out of range&quot;</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">returnItem</span> <span class="k">instanceof</span> <span class="n">Item</span> <span class="o">-&gt;</span> <span class="n">Item</span> <span class="n">returnItem</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">print</span><span class="p">(</span><span class="s">&quot;Item is: &quot;</span> <span class="o">+</span> <span class="n">returnItem</span><span class="p">.</span><span class="na">toString</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">print</span><span class="p">(</span><span class="s">&quot;isn&#39;t a postive int: &quot;</span> <span class="o">+</span> <span class="n">myVal</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">Item</span><span class="p">.</span><span class="na">optional</span> <span class="nf">getItem</span><span class="p">(</span><span class="n">PositiveInt</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//We know that postive int so no need to check.</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">arrayList</span><span class="p">.</span><span class="na">size</span><span class="p">())</span> <span class="p">{</span> <span class="c1">//This could be some computationally expensive function that can&#39;t be properly checked at compile time.</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">arrayList</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However, as all functions are objects and inherit from the function class,
they contain an inherent and overridable validator for their inputs.</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kd">abstract</span> <span class="n">AbstractFunction</span> <span class="p">{</span>
    <span class="p">...</span><span class="na">anything</span> <span class="n">run</span><span class="p">(</span><span class="n">anything</span> <span class="p">...</span><span class="na">arguments</span><span class="p">);</span>
    <span class="p">...</span><span class="na">anything</span> <span class="n">validate</span><span class="p">(</span><span class="n">anything</span> <span class="p">...</span><span class="na">arguments</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">onInvalid</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">onValid</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="p">...</span><span class="na">ReturnTypes</span><span class="p">,</span> <span class="p">...</span><span class="na">ArgumentTypes</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">AbstractFunction</span> <span class="p">{</span>

    <span class="n">ReturnTypes</span> <span class="nf">run</span><span class="p">(</span><span class="n">ArgumentTypes</span> <span class="p">...</span><span class="na">types</span><span class="p">);</span>


    <span class="c1">//A list of anything can be turned into its optional types.</span>
    <span class="c1">//A list of types can also be turned into its optional variants.</span>
    <span class="n">ArgumentTypes</span><span class="p">.</span><span class="na">optionals</span> <span class="nf">validate</span><span class="p">(</span><span class="n">Any</span> <span class="p">...</span><span class="na">types</span><span class="o">[</span><span class="n">ArgumentTypes</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">types</span><span class="p">.</span><span class="na">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">types</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="n">subset</span> <span class="n">ArgumentTypes</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="p">:</span> <span class="n">subsetType</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">onValid</span><span class="p">();</span>
                <span class="n">returnChain</span> <span class="n">subsetType</span><span class="p">;</span> <span class="c1">//Return chain allows you to chain return calls if they return multiple things.</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">onInvalid</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">returnChainComplete</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">//If you use return chain you must call returnChainComplete with whatever default values you wish.</span>
        <span class="c1">//In our scenario this would never be called, but this is needed for compiler checks.</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<p>With these functions and types, you can actually rewrite the previous above code to be more succinct.</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="n">typedef</span> <span class="n">PostiveInt</span> <span class="p">:</span> <span class="n">Set</span><span class="p">.</span><span class="na">naturalNumbers</span><span class="p">.</span><span class="na">greaterThan</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">myVal</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">getItem</span><span class="p">.</span><span class="na">validate</span><span class="p">(</span><span class="n">myVal</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">myVal</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">getItem</span><span class="p">(</span><span class="n">myVal</span><span class="p">):</span> <span class="n">ItemOptional</span> <span class="n">returnItem</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">print</span><span class="p">(</span><span class="s">&quot;Item out of range&quot;</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">returnItem</span> <span class="k">instanceof</span> <span class="n">Item</span> <span class="o">-&gt;</span> <span class="n">Item</span> <span class="n">returnItem</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">print</span><span class="p">(</span><span class="s">&quot;Item is: &quot;</span> <span class="o">+</span> <span class="n">returnItem</span><span class="p">.</span><span class="na">toString</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//You can override function objects functions in the class where they are declared, or anywhere where they are used.</span>
    <span class="n">getItem</span><span class="p">.</span><span class="na">onInvalid</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">print</span><span class="p">(</span><span class="s">&quot;Error, Isn&#39;t a postive int!&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Item</span><span class="p">.</span><span class="na">optional</span> <span class="nf">getItem</span><span class="p">(</span><span class="n">PositiveInt</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//We know that postive int so no need to check.</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">arrayList</span><span class="p">.</span><span class="na">size</span><span class="p">())</span> <span class="p">{</span> <span class="c1">//This could be some computationally expensive function that can&#39;t be properly checked at compile time.</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">arrayList</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="functions.html" class="btn btn-neutral float-left" title="Functions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="type.html" class="btn btn-neutral float-right" title="Type" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Malek.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>